/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 ******************************************************************************
El funcionamiento de este código tiene como propósito hacer encender un Led y
apagarlo, mediante el uso de una interrupción por timmer
ademas se encuentra especificado la configuración que se le debe hacer
a un timmer. En este caso el timmer 2


 ******************************************************************************
 ******************************************************************************
 */

#include "stm32l476xx.h"


#define LEDDELAY_1    1000000 //Se define un reatardo para un segundo


/*************************************************
* function declarations
*************************************************/
int main(void);
void delay(volatile uint32_t s);


void TIM2_IRQHandler(void)
{

	while(1){

			delay(LEDDELAY_1);   	//Llamado a función de reatardo para temporizador
			GPIOA->ODR |=(1<<5); 	//Encender led
			delay(LEDDELAY_1); 		////Llamado a función de reatardo para temporizador
			GPIOA->ODR &=(0<<5); 	//apagar led

	}

}

int main(void)
{
	RCC->AHB2ENR = 0x00000005; //Registro de habilitación de reloj periférico AHB2
								   //Se habilita para los GPIOA y GPIOC

	// Se configura el pin 5 (bits 11-10 del registro) del GPIOA como salida
	//Este pin es el led verde del sistema de desarrollo
	GPIOA->MODER &= 0xABFFFFFF;		// Se limpia los bits 11-10 para el pin 5
	GPIOA->MODER &= 0xFFFFF7FF;		// Para configurar como salida se escribe en los bits
									//11-10 el valor 01 respectivamente.

	// Se configura el pin 13 (bits 27-26 del registro) del GPIOC como entrada
	//Este pin corresponde a el boton de usuario del sistema de desarrollo
	GPIOC->MODER &= 0xFFFFFFFF;		// Se limpia los bits 27-26 para el pin 13
	GPIOC->MODER &= 0xF3FFFFFF;		// Para configurar como entrada se escribe en los bits
									//27-26 el valor 00 respectivamente.

    RCC->APB1ENR1 |= (1<<0);  //Se activa el reloj del timmer 2

    RCC->APB2ENR = 0x00000001;  //Se activa SYSCFG clock para configurar varios aspectos del sistema,
    						 	// como la compensación de E/S



    TIM2->PSC = 8;   //Aquí es donde se define el prescalador del timmer 2

    TIM2->ARR = 100;   //Aquí se establece el periodo del pulso

    // Update Interrupt Enable
    TIM2->DIER |= (1 << 0);

    NVIC_SetPriority(TIM2_IRQn, 2); // Se define una prioridad de nivel 1

    // Se activa la interrupción configurada
    NVIC_EnableIRQ(TIM2_IRQn);

    // Se activa el modulo del timmer 2
    TIM2->CR1 |= (1 << 0);



	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}

void delay(volatile uint32_t s)
{
	for(s; s>0; s--){
		// Resetear el timmer
		TIM2->EGR |= 0x0001;
		// Espere hasta que el temporizador llegue a 1000
		// Son 1000 porque el temporizador está funcionando a 1 MHz y 1000
		// genera 1 milisegundo
 		while(TIM2->CNT < 1000);
	}
}
